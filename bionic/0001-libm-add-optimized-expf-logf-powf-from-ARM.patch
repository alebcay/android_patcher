From 301a9922bd8dc7b42555ef193bce7eac7effc058 Mon Sep 17 00:00:00 2001
From: Jake Weinstein <xboxlover360@gmail.com>
Date: Mon, 1 Aug 2016 13:57:12 -0400
Subject: [PATCH 01/23] libm: add optimized expf/logf/powf from ARM

* Taken from here: https://github.com/arm-software/optimized-routines

Change-Id: I18c22f1a3a2c02180eee818f2f6cb8777f4bcc69
Signed-off-by: mydongistiny <jaysonedson@gmail.com>
---
 libm/Android.bp                                   |   2 +
 libm/upstream-freebsd/lib/msun/src/dunder.c       |  66 ++
 libm/upstream-freebsd/lib/msun/src/e_expf.c       | 198 +++--
 libm/upstream-freebsd/lib/msun/src/e_logf.c       | 232 ++++--
 libm/upstream-freebsd/lib/msun/src/e_powf.c       | 895 ++++++++++++++++------
 libm/upstream-freebsd/lib/msun/src/funder.c       |  65 ++
 libm/upstream-freebsd/lib/msun/src/ieee_status.c  |  52 ++
 libm/upstream-freebsd/lib/msun/src/math_private.h | 101 +++
 8 files changed, 1218 insertions(+), 393 deletions(-)
 create mode 100644 libm/upstream-freebsd/lib/msun/src/dunder.c
 create mode 100644 libm/upstream-freebsd/lib/msun/src/funder.c
 create mode 100644 libm/upstream-freebsd/lib/msun/src/ieee_status.c

diff --git a/libm/Android.bp b/libm/Android.bp
index 75e89572b..0bdab940a 100644
--- a/libm/Android.bp
+++ b/libm/Android.bp
@@ -13,6 +13,7 @@ cc_library {
         "upstream-freebsd/lib/msun/bsdsrc/b_tgamma.c",
         "upstream-freebsd/lib/msun/src/catrig.c",
         "upstream-freebsd/lib/msun/src/catrigf.c",
+        "upstream-freebsd/lib/msun/src/dunder.c",
         "upstream-freebsd/lib/msun/src/e_acos.c",
         "upstream-freebsd/lib/msun/src/e_acosf.c",
         "upstream-freebsd/lib/msun/src/e_acosh.c",
@@ -63,6 +64,7 @@ cc_library {
         "upstream-freebsd/lib/msun/src/e_sinhf.c",
         "upstream-freebsd/lib/msun/src/e_sqrt.c",
         "upstream-freebsd/lib/msun/src/e_sqrtf.c",
+        "upstream-freebsd/lib/msun/src/funder.c",
         "upstream-freebsd/lib/msun/src/k_cos.c",
         "upstream-freebsd/lib/msun/src/k_cosf.c",
         "upstream-freebsd/lib/msun/src/k_exp.c",
diff --git a/libm/upstream-freebsd/lib/msun/src/dunder.c b/libm/upstream-freebsd/lib/msun/src/dunder.c
new file mode 100644
index 000000000..a09ae73fe
--- /dev/null
+++ b/libm/upstream-freebsd/lib/msun/src/dunder.c
@@ -0,0 +1,66 @@
+/*
+ *  dunder.c - manually provoke FP exceptions for
+ *
+ *  Copyright (C) 2009-2015, ARM Limited, All Rights Reserved
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  This file is part of the Optimized Routines project
+ */
+
+
+#include "math_private.h"
+#include <fenv.h>
+
+__inline double _dbl_infnan(double x)
+{
+  return x+x;
+}
+
+__inline double _dbl_infnan2(double x, double y)
+{
+  return x+y;
+}
+
+double _dbl_underflow(void)
+{
+#ifdef CLANG_EXCEPTIONS
+  feraiseexcept(FE_UNDERFLOW);
+#endif
+  return 0x1p-767 * 0x1p-767;
+}
+
+double _dbl_overflow(void)
+{
+#ifdef CLANG_EXCEPTIONS
+  feraiseexcept(FE_OVERFLOW);
+#endif
+  return 0x1p+769 * 0x1p+769;
+}
+
+double _dbl_invalid(void)
+{
+#ifdef CLANG_EXCEPTIONS
+  feraiseexcept(FE_INVALID);
+#endif
+  return 0.0 / 0.0;
+}
+
+double _dbl_divzero(void)
+{
+#ifdef CLANG_EXCEPTIONS
+  feraiseexcept(FE_DIVBYZERO);
+#endif
+  return 1.0 / 0.0;
+}
diff --git a/libm/upstream-freebsd/lib/msun/src/e_expf.c b/libm/upstream-freebsd/lib/msun/src/e_expf.c
index b1fe2c537..c543bdf7f 100644
--- a/libm/upstream-freebsd/lib/msun/src/e_expf.c
+++ b/libm/upstream-freebsd/lib/msun/src/e_expf.c
@@ -1,98 +1,132 @@
-/* e_expf.c -- float version of e_exp.c.
- * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
- */
-
 /*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *  e_expf.c - single-precision exp function
+ *
+ *  Copyright (C) 2009-2015, ARM Limited, All Rights Reserved
+ *  SPDx-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
  *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  This file is part of the Optimized Routines project
  */
 
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD$");
-
-#include <float.h>
-
-#include "math.h"
-#include "math_private.h"
-
-static const float
-one	= 1.0,
-halF[2]	= {0.5,-0.5,},
-o_threshold=  8.8721679688e+01,  /* 0x42b17180 */
-u_threshold= -1.0397208405e+02,  /* 0xc2cff1b5 */
-ln2HI[2]   ={ 6.9314575195e-01,		/* 0x3f317200 */
-	     -6.9314575195e-01,},	/* 0xbf317200 */
-ln2LO[2]   ={ 1.4286067653e-06,  	/* 0x35bfbe8e */
-	     -1.4286067653e-06,},	/* 0xb5bfbe8e */
-invln2 =  1.4426950216e+00, 		/* 0x3fb8aa3b */
 /*
- * Domain [-0.34568, 0.34568], range ~[-4.278e-9, 4.447e-9]:
- * |x*(exp(x)+1)/(exp(x)-1) - p(x)| < 2**-27.74
+ * Algorithm was once taken from Cody & Waite, but has been munged
+ * out of all recognition by SGT.
  */
-P1 =  1.6666625440e-1,		/*  0xaaaa8f.0p-26 */
-P2 = -2.7667332906e-3;		/* -0xb55215.0p-32 */
 
-static volatile float
-huge	= 1.0e+30,
-twom100 = 7.8886090522e-31;      /* 2**-100=0x0d800000 */
+#include "math.h"
+#include "math_private.h"
+#include <math.h>
+#include <errno.h>
 
 float
 __ieee754_expf(float x)
 {
-	float y,hi=0.0,lo=0.0,c,t,twopk;
-	int32_t k=0,xsb;
-	u_int32_t hx;
+  int N; float xn, g, Rg, Result;
+  unsigned ix = fai(x), edgecaseflag = 0;
+
+  /*
+   * Handle infinities, NaNs and big numbers.
+   */
+  if (__builtin_expect((ix << 1) - 0x67000000 > 0x85500000 - 0x67000000, 0)) {
+    if (!(0x7f800000 & ~ix)) {
+      if (ix == 0xff800000)
+        return 0.0f;
+      else
+        return FLOAT_INFNAN(x);/* do the right thing with both kinds of NaN and with +inf */
+    } else if ((ix << 1) < 0x67000000) {
+      return 1.0f;               /* magnitude so small the answer can't be distinguished from 1 */
+    } else if ((ix << 1) > 0x85a00000) {
+      __set_errno(ERANGE);
+      if (ix & 0x80000000) {
+        return FLOAT_UNDERFLOW;
+      } else {
+        return FLOAT_OVERFLOW;
+      }
+    } else {
+      edgecaseflag = 1;
+    }
+  }
+
+  /*
+   * Split the input into an integer multiple of log(2)/4, and a
+   * fractional part.
+   */
+  xn = x * (4.0f*1.4426950408889634074f);
+#ifdef __TARGET_FPU_SOFTVFP
+  xn = _frnd(xn);
+  N = (int)xn;
+#else
+  N = (int)(xn + (ix & 0x80000000 ? -0.5f : 0.5f));
+  xn = N;
+#endif
+  g = (x - xn * 0x1.62ep-3F) - xn * 0x1.0bfbe8p-17F;  /* prec-and-a-half representation of log(2)/4 */
+
+  /*
+   * Now we compute exp(x) in, conceptually, three parts:
+   *  - a pure power of two which we get from N>>2
+   *  - exp(g) for g in [-log(2)/8,+log(2)/8], which we compute
+   *    using a Remez-generated polynomial approximation
+   *  - exp(k*log(2)/4) (aka 2^(k/4)) for k in [0..3], which we
+   *    get from a lookup table in precision-and-a-half and
+   *    multiply by g.
+   *
+   * We gain a bit of extra precision by the fact that actually
+   * our polynomial approximation gives us exp(g)-1, and we add
+   * the 1 back on by tweaking the prec-and-a-half multiplication
+   * step.
+   *
+   * Coefficients generated by the command
+
+./auxiliary/remez.jl --variable=g --suffix=f -- '-log(BigFloat(2))/8' '+log(BigFloat(2))/8' 3 0 '(expm1(x))/x'
 
-	GET_FLOAT_WORD(hx,x);
-	xsb = (hx>>31)&1;		/* sign bit of x */
-	hx &= 0x7fffffff;		/* high word of |x| */
+  */
+  Rg = g * (
+            9.999999412829185331953781321128516523408059996430919985217971370689774264850229e-01f+g*(4.999999608551332693833317084753864837160947932961832943901913087652889900683833e-01f+g*(1.667292360203016574303631953046104769969440903672618034272397630620346717392378e-01f+g*(4.168230895653321517750133783431970715648192153539929404872173693978116154823859e-02f)))
+            );
 
-    /* filter out non-finite argument */
-	if(hx >= 0x42b17218) {			/* if |x|>=88.721... */
-	    if(hx>0x7f800000)
-		 return x+x;	 		/* NaN */
-            if(hx==0x7f800000)
-		return (xsb==0)? x:0.0;		/* exp(+-inf)={inf,0} */
-	    if(x > o_threshold) return huge*huge; /* overflow */
-	    if(x < u_threshold) return twom100*twom100; /* underflow */
-	}
+  /*
+   * Do the table lookup and combine it with Rg, to get our final
+   * answer apart from the exponent.
+   */
+  {
+    static const float twotokover4top[4] = { 0x1p+0F, 0x1.306p+0F, 0x1.6ap+0F, 0x1.ae8p+0F };
+    static const float twotokover4bot[4] = { 0x0p+0F, 0x1.fc1464p-13F, 0x1.3cccfep-13F, 0x1.3f32b6p-13F };
+    static const float twotokover4all[4] = { 0x1p+0F, 0x1.306fep+0F, 0x1.6a09e6p+0F, 0x1.ae89fap+0F };
+    int index = (N & 3);
+    Rg = twotokover4top[index] + (twotokover4bot[index] + twotokover4all[index]*Rg);
+    N >>= 2;
+  }
 
-    /* argument reduction */
-	if(hx > 0x3eb17218) {		/* if  |x| > 0.5 ln2 */
-	    if(hx < 0x3F851592) {	/* and |x| < 1.5 ln2 */
-		hi = x-ln2HI[xsb]; lo=ln2LO[xsb]; k = 1-xsb-xsb;
-	    } else {
-		k  = invln2*x+halF[xsb];
-		t  = k;
-		hi = x - t*ln2HI[0];	/* t*ln2HI is exact here */
-		lo = t*ln2LO[0];
-	    }
-	    STRICT_ASSIGN(float, x, hi - lo);
-	}
-	else if(hx < 0x39000000)  {	/* when |x|<2**-14 */
-	    if(huge+x>one) return one+x;/* trigger inexact */
-	}
-	else k = 0;
+  /*
+   * Combine the output exponent and mantissa, and return.
+   */
+  if (__builtin_expect(edgecaseflag, 0)) {
+    Result = fhex(((N/2) << 23) + 0x3f800000);
+    Result *= Rg;
+    Result *= fhex(((N-N/2) << 23) + 0x3f800000);
+    /*
+     * Step not mentioned in C&W: set errno reliably.
+     */
+    if (fai(Result) == 0)
+      return MATHERR_EXPF_UFL(Result);
+    if (fai(Result) == 0x7f800000)
+      return MATHERR_EXPF_OFL(Result);
+    return FLOAT_CHECKDENORM(Result);
+  } else {
+    Result = fhex(N * 8388608.0f + (float)0x3f800000);
+    Result *= Rg;
+  }
 
-    /* x is now in primary range */
-	t  = x*x;
-	if(k >= -125)
-	    SET_FLOAT_WORD(twopk,0x3f800000+(k<<23));
-	else
-	    SET_FLOAT_WORD(twopk,0x3f800000+((k+100)<<23));
-	c  = x - t*(P1+t*P2);
-	if(k==0) 	return one-((x*c)/(c-(float)2.0)-x);
-	else 		y = one-((lo-(x*c)/((float)2.0-c))-hi);
-	if(k >= -125) {
-	    if(k==128) return y*2.0F*0x1p127F;
-	    return y*twopk;
-	} else {
-	    return y*twopk*twom100;
-	}
+  return Result;
 }
diff --git a/libm/upstream-freebsd/lib/msun/src/e_logf.c b/libm/upstream-freebsd/lib/msun/src/e_logf.c
index ec3985fcb..2adab9a85 100644
--- a/libm/upstream-freebsd/lib/msun/src/e_logf.c
+++ b/libm/upstream-freebsd/lib/msun/src/e_logf.c
@@ -1,89 +1,169 @@
-/* e_logf.c -- float version of e_log.c.
- * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
- */
-
 /*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *  e_logf.c - single precision log function
+ *
+ *  Copyright (C) 2009-2015, ARM Limited, All Rights Reserved
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
  *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
+ *  This file is part of the Optimized Routines project
  */
 
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD$");
+/*
+ * Algorithm was once taken from Cody & Waite, but has been munged
+ * out of all recognition by SGT.
+ */
 
 #include "math.h"
 #include "math_private.h"
+#include <math.h>
+#include <errno.h>
 
-static const float
-ln2_hi =   6.9313812256e-01,	/* 0x3f317180 */
-ln2_lo =   9.0580006145e-06,	/* 0x3717f7d1 */
-two25 =    3.355443200e+07,	/* 0x4c000000 */
-/* |(log(1+s)-log(1-s))/s - Lg(s)| < 2**-34.24 (~[-4.95e-11, 4.97e-11]). */
-Lg1 =      0xaaaaaa.0p-24,	/* 0.66666662693 */
-Lg2 =      0xccce13.0p-25,	/* 0.40000972152 */
-Lg3 =      0x91e9ee.0p-25,	/* 0.28498786688 */
-Lg4 =      0xf89e26.0p-26;	/* 0.24279078841 */
-
-static const float zero   =  0.0;
-static volatile float vzero = 0.0;
 
 float
 __ieee754_logf(float x)
 {
-	float hfsq,f,s,z,R,w,t1,t2,dk;
-	int32_t k,ix,i,j;
-
-	GET_FLOAT_WORD(ix,x);
-
-	k=0;
-	if (ix < 0x00800000) {			/* x < 2**-126  */
-	    if ((ix&0x7fffffff)==0)
-		return -two25/vzero;		/* log(+-0)=-inf */
-	    if (ix<0) return (x-x)/zero;	/* log(-#) = NaN */
-	    k -= 25; x *= two25; /* subnormal number, scale up x */
-	    GET_FLOAT_WORD(ix,x);
-	}
-	if (ix >= 0x7f800000) return x+x;
-	k += (ix>>23)-127;
-	ix &= 0x007fffff;
-	i = (ix+(0x95f64<<3))&0x800000;
-	SET_FLOAT_WORD(x,ix|(i^0x3f800000));	/* normalize x or x/2 */
-	k += (i>>23);
-	f = x-(float)1.0;
-	if((0x007fffff&(0x8000+ix))<0xc000) {	/* -2**-9 <= f < 2**-9 */
-	    if(f==zero) {
-		if(k==0) {
-		    return zero;
-		} else {
-		    dk=(float)k;
-		    return dk*ln2_hi+dk*ln2_lo;
-		}
-	    }
-	    R = f*f*((float)0.5-(float)0.33333333333333333*f);
-	    if(k==0) return f-R; else {dk=(float)k;
-	    	     return dk*ln2_hi-((R-dk*ln2_lo)-f);}
-	}
- 	s = f/((float)2.0+f);
-	dk = (float)k;
-	z = s*s;
-	i = ix-(0x6147a<<3);
-	w = z*z;
-	j = (0x6b851<<3)-ix;
-	t1= w*(Lg2+w*Lg4);
-	t2= z*(Lg1+w*Lg3);
-	i |= j;
-	R = t2+t1;
-	if(i>0) {
-	    hfsq=(float)0.5*f*f;
-	    if(k==0) return f-(hfsq-s*(hfsq+R)); else
-		     return dk*ln2_hi-((hfsq-(s*(hfsq+R)+dk*ln2_lo))-f);
-	} else {
-	    if(k==0) return f-s*(f-R); else
-		     return dk*ln2_hi-((s*(f-R)-dk*ln2_lo)-f);
-	}
+    int N = 0;
+    int aindex;
+    float a, s;
+    unsigned ix = fai(x);
+
+    if (__builtin_expect((ix - 0x00800000) >= 0x7f800000 - 0x00800000, 0)) {
+        if ((ix << 1) > 0xff000000) /* NaN */
+            return FLOAT_INFNAN(x);
+        if (ix == 0x7f800000)          /* +inf */
+            return x;
+        if (x < 0) {                   /* anything negative */
+            return MATHERR_LOGF_NEG(x);
+        }
+        if (x == 0) {
+            return MATHERR_LOGF_0(x);
+        }
+        /* That leaves denormals. */
+        N = -23;
+        x *= 0x1p+23F;
+        ix = fai(x);
+    }
+
+    /*
+     * Separate X into three parts:
+     *  - 2^N for some integer N
+     *  - a number a of the form (1+k/8) for k=0,...,7
+     *  - a residual which we compute as s = (x-a)/(x+a), for
+     *    x=X/2^N.
+     *
+     * We pick the _nearest_ (N,a) pair, so that (x-a) has magnitude
+     * at most 1/16. Hence, we must round things that are just
+     * _below_ a power of two up to the next power of two, so this
+     * isn't as simple as extracting the raw exponent of the FP
+     * number. Instead we must grab the exponent together with the
+     * top few bits of the mantissa, and round (in integers) there.
+     */
+    {
+        int rounded = ix + 0x00080000;
+        int Nnew = (rounded >> 23) - 127;
+        aindex = (rounded >> 20) & 7;
+        a = fhex(0x3f800000 + (aindex << 20));
+        N += Nnew;
+        x = fhex(ix - (Nnew << 23));
+    }
+
+    if (!N && !aindex) {
+        /*
+         * Use an alternative strategy for very small |x|, which
+         * avoids the 1ULP of relative error introduced in the
+         * computation of s. If our nearest (N,a) pair is N=0,a=1,
+         * that means we have -1/32 < x-a < 1/16, on which interval
+         * the ordinary series for log(1+z) (setting z-x-a) will
+         * converge adequately fast; so we can simply find an
+         * approximation to log(1+z)/z good on that interval and
+         * scale it by z on the way out.
+         *
+         * Coefficients generated by the command
+
+./auxiliary/remez.jl --variable=z --suffix=f -- '-1/BigFloat(32)' '+1/BigFloat(16)' 3 0 '(log1p(x)-x)/x^2'
+
+         */
+        float z = x - 1.0f;
+        float p = z*z * (
+            -4.999999767382730053173434595877399055021398381370452534949864039404089549132551e-01f+z*(3.333416379155995401749506866323446447523793085809161350343357014272193712456391e-01f+z*(-2.501299948811686421962724839011563450757435183422532362736159418564644404218257e-01f+z*(1.903576945606738444146078468935429697455230136403008172485495359631510244557255e-01f)))
+            );
+
+        return z + p;
+    }
+
+    /*
+     * Now we have N, a and x correct, so that |x-a| <= 1/16.
+     * Compute s.
+     *
+     * (Since |x+a| >= 2, this means that |s| will be at most 1/32.)
+     */
+    s = (x - a) / (x + a);
+
+    /*
+     * The point of computing s = (x-a)/(x+a) was that this makes x
+     * equal to a * (1+s)/(1-s). So we can now compute log(x) by
+     * means of computing log((1+s)/(1-s)) (which has a more
+     * efficiently converging series), and adding log(a) which we
+     * obtain from a lookup table.
+     *
+     * So our full answer to log(X) is now formed by adding together
+     * N*log(2) + log(a) + log((1+s)/(1-s)).
+     *
+     * Now log((1+s)/(1-s)) has the exact Taylor series
+     *
+     *   2s + 2s^3/3 + 2s^5/5 + ...
+     *
+     * and what we do is to compute all but the first term of that
+     * as a polynomial approximation in s^2, then add on the first
+     * term - and all the other bits and pieces above - in
+     * precision-and-a-half so as to keep the total error down.
+     */
+    {
+        float s2 = s*s;
+
+        /*
+         * We want a polynomial L(s^2) such that
+         *
+         *    2s + s^3*L(s^2) = log((1+s)/(1-s))
+         *
+         * => L(s^2) = (log((1+s)/(1-s)) - 2s) / s^3
+         *
+         * => L(z) = (log((1+sqrt(z))/(1-sqrt(z))) - 2*sqrt(z)) / sqrt(z)^3
+         *
+         * The required range of the polynomial is only [0,1/32^2].
+         *
+         * Our accuracy requirement for the polynomial approximation
+         * is that we don't want to introduce any error more than
+         * about 2^-23 times the _top_ bit of s. But the value of
+         * the polynomial has magnitude about s^3; and since |s| <
+         * 2^-5, this gives us |s^3/s| < 2^-10. In other words,
+         * our approximation only needs to be accurate to 13 bits or
+         * so before its error is lost in the noise when we add it
+         * to everything else.
+         *
+         * Coefficients generated by the command
+
+./auxiliary/remez.jl --variable=s2 --suffix=f -- '0' '1/BigFloat(32^2)' 1 0 '(abs(x) < 1e-20 ? BigFloat(2)/3 + 2*x/5 + 2*x^2/7 + 2*x^3/9 : (log((1+sqrt(x))/(1-sqrt(x)))-2*sqrt(x))/sqrt(x^3))'
+
+         */
+        float p = s * s2 * (
+            6.666666325680271091157649745099739739798210281016897722498744752867165138320995e-01f+s2*(4.002792299542401431889592846825025487338520940900492146195427243856292349188402e-01f)
+            );
+
+        static const float log2hi = 0x1.62ep-1F, log2lo = 0x1.0bfbe8p-15F;
+        static const float logahi[8] = { 0x0p+0F, 0x1.e26p-4F, 0x1.c8ep-3F, 0x1.46p-2F, 0x1.9f2p-2F, 0x1.f12p-2F, 0x1.1e8p-1F, 0x1.41cp-1F };
+        static const float logalo[8] = { 0x0p+0F, 0x1.076e2ap-16F, 0x1.f7c79ap-15F, 0x1.8bc21cp-14F, 0x1.23eccp-14F, 0x1.1ebf5ep-15F, 0x1.7d79c2p-15F, 0x1.8fe846p-13F };
+        return (N*log2hi + logahi[aindex]) + (2.0f*s + (N*log2lo + logalo[aindex] + p));
+    }
 }
diff --git a/libm/upstream-freebsd/lib/msun/src/e_powf.c b/libm/upstream-freebsd/lib/msun/src/e_powf.c
index 5c4647887..c0ca00af2 100644
--- a/libm/upstream-freebsd/lib/msun/src/e_powf.c
+++ b/libm/upstream-freebsd/lib/msun/src/e_powf.c
@@ -1,249 +1,674 @@
-/* e_powf.c -- float version of e_pow.c.
- * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
- */
-
 /*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *  e_powf.c - single-precision power function
+ *
+ *  Copyright (C) 2009-2015, ARM Limited, All Rights Reserved
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
  *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
+ *  This file is part of the Optimized Routines project
  */
 
-#include <sys/cdefs.h>
-__FBSDID("$FreeBSD$");
-
 #include "math.h"
 #include "math_private.h"
-
-static const float
-bp[] = {1.0, 1.5,},
-dp_h[] = { 0.0, 5.84960938e-01,}, /* 0x3f15c000 */
-dp_l[] = { 0.0, 1.56322085e-06,}, /* 0x35d1cfdc */
-zero    =  0.0,
-one	=  1.0,
-two	=  2.0,
-two24	=  16777216.0,	/* 0x4b800000 */
-huge	=  1.0e30,
-tiny    =  1.0e-30,
-	/* poly coefs for (3/2)*(log(x)-2s-2/3*s**3 */
-L1  =  6.0000002384e-01, /* 0x3f19999a */
-L2  =  4.2857143283e-01, /* 0x3edb6db7 */
-L3  =  3.3333334327e-01, /* 0x3eaaaaab */
-L4  =  2.7272811532e-01, /* 0x3e8ba305 */
-L5  =  2.3066075146e-01, /* 0x3e6c3255 */
-L6  =  2.0697501302e-01, /* 0x3e53f142 */
-P1   =  1.6666667163e-01, /* 0x3e2aaaab */
-P2   = -2.7777778450e-03, /* 0xbb360b61 */
-P3   =  6.6137559770e-05, /* 0x388ab355 */
-P4   = -1.6533901999e-06, /* 0xb5ddea0e */
-P5   =  4.1381369442e-08, /* 0x3331bb4c */
-lg2  =  6.9314718246e-01, /* 0x3f317218 */
-lg2_h  =  6.93145752e-01, /* 0x3f317200 */
-lg2_l  =  1.42860654e-06, /* 0x35bfbe8c */
-ovt =  4.2995665694e-08, /* -(128-log2(ovfl+.5ulp)) */
-cp    =  9.6179670095e-01, /* 0x3f76384f =2/(3ln2) */
-cp_h  =  9.6191406250e-01, /* 0x3f764000 =12b cp */
-cp_l  = -1.1736857402e-04, /* 0xb8f623c6 =tail of cp_h */
-ivln2    =  1.4426950216e+00, /* 0x3fb8aa3b =1/ln2 */
-ivln2_h  =  1.4426879883e+00, /* 0x3fb8aa00 =16b 1/ln2*/
-ivln2_l  =  7.0526075433e-06; /* 0x36eca570 =1/ln2 tail*/
+#include <math.h>
+#include <errno.h>
+#include "ieee_status.c"
 
 float
 __ieee754_powf(float x, float y)
 {
-	float z,ax,z_h,z_l,p_h,p_l;
-	float y1,t1,t2,r,s,sn,t,u,v,w;
-	int32_t i,j,k,yisint,n;
-	int32_t hx,hy,ix,iy,is;
-
-	GET_FLOAT_WORD(hx,x);
-	GET_FLOAT_WORD(hy,y);
-	ix = hx&0x7fffffff;  iy = hy&0x7fffffff;
-
-    /* y==zero: x**0 = 1 */
-	if(iy==0) return one;
-
-    /* x==1: 1**y = 1, even if y is NaN */
-	if (hx==0x3f800000) return one;
-
-    /* y!=zero: result is NaN if either arg is NaN */
-	if(ix > 0x7f800000 ||
-	   iy > 0x7f800000)
-		return (x+0.0F)+(y+0.0F);
-
-    /* determine if y is an odd int when x < 0
-     * yisint = 0	... y is not an integer
-     * yisint = 1	... y is an odd int
-     * yisint = 2	... y is an even int
+    float logh, logl;
+    float rlogh, rlogl;
+    float sign = 1.0f;
+    int expadjust = 0;
+    unsigned ix, iy;
+
+    ix = fai(x);
+    iy = fai(y);
+
+    if (__builtin_expect((ix - 0x00800000) >= (0x7f800000 - 0x00800000) ||
+                         ((iy << 1) + 0x02000000) < 0x40000000, 0)) {
+        /*
+         * The above test rules out, as quickly as I can see how to,
+         * all possible inputs except for a normalised positive x
+         * being raised to the power of a normalised (and not
+         * excessively small) y. That's the fast-path case: if
+         * that's what the user wants, we can skip all of the
+         * difficult special-case handling.
+         *
+         * Now we must identify, as efficiently as we can, cases
+         * which will return to the fast path with a little tidying
+         * up. These are, in order of likelihood and hence of
+         * processing:
+         *
+         *  - a normalised _negative_ x raised to the power of a
+         *    non-zero finite y. Having identified this case, we
+         *    must categorise y into one of the three categories
+         *    'odd integer', 'even integer' and 'non-integer'; for
+         *    the last of these we return an error, while for the
+         *    other two we rejoin the main code path having rendered
+         *    x positive and stored an appropriate sign to append to
+         *    the eventual result.
+         *
+         *  - a _denormal_ x raised to the power of a non-zero
+         *    finite y, in which case we multiply it up by a power
+         *    of two to renormalise it, store an appropriate
+         *    adjustment for its base-2 logarithm, and depending on
+         *    the sign of y either return straight to the main code
+         *    path or go via the categorisation of y above.
+         *
+         *  - any of the above kinds of x raised to the power of a
+         *    zero, denormal, nearly-denormal or nearly-infinite y,
+         *    in which case we must do the checks on x as above but
+         *    otherwise the algorithm goes through basically
+         *    unchanged. Denormal and very tiny y values get scaled
+         *    up to something not in range of accidental underflow
+         *    when split into prec-and-a-half format; very large y
+         *    values get scaled down by a factor of two to prevent
+         *    CLEARBOTTOMHALF's round-up from overflowing them to
+         *    infinity. (Of course the _output_ will overflow either
+         *    way - the largest y value that can possibly yield a
+         *    finite result is well below this range anyway - so
+         *    this is a safe change.)
+         */
+        if (__builtin_expect(((iy << 1) + 0x02000000) >= 0x40000000, 1)) {   /* normalised and sensible y */
+            y_ok_check_x:
+
+            if (__builtin_expect((ix - 0x80800000) < (0xff800000 - 0x80800000), 1)) {   /* normal but negative x */
+                y_ok_x_negative:
+
+                x = fabsf(x);
+                ix = fai(x);
+
+                /*
+                 * Determine the parity of y, if it's an integer at
+                 * all.
+                 */
+                {
+                    int yexp, yunitsbit;
+
+                    /*
+                     * Find the exponent of y.
+                     */
+                    yexp = (iy >> 23) & 0xFF;
+                    /*
+                     * Numbers with an exponent smaller than 0x7F
+                     * are strictly smaller than 1, and hence must
+                     * be fractional.
+                     */
+                    if (yexp < 0x7F)
+                        return MATHERR_POWF_NEGFRAC(x,y);
+                    /*
+                     * Numbers with an exponent at least 0x97 are by
+                     * definition even integers.
+                     */
+                    if (yexp >= 0x97)
+                        goto mainpath;  /* rejoin main code, giving positive result */
+                    /*
+                     * In between, we must check the mantissa.
+                     *
+                     * Note that this case includes yexp==0x7f,
+                     * which means 1 point something. In this case,
+                     * the 'units bit' we're testing is semantically
+                     * the lowest bit of the exponent field, not the
+                     * leading 1 on the mantissa - but fortunately,
+                     * that bit position will just happen to contain
+                     * the 1 that we would wish it to, because the
+                     * exponent describing that particular case just
+                     * happens to be odd.
+                     */
+                    yunitsbit = 0x96 - yexp;
+                    if (iy & ((1 << yunitsbit)-1))
+                        return MATHERR_POWF_NEGFRAC(x,y);
+                    else if (iy & (1 << yunitsbit))
+                        sign = -1.0f;  /* y is odd; result should be negative */
+                    goto mainpath;     /* now we can rejoin the main code */
+                }
+            } else if (__builtin_expect((ix << 1) != 0 && (ix << 1) < 0x01000000, 0)) {   /* denormal x */
+                /*
+                 * Renormalise x.
+                 */
+                x *= 0x1p+27F;
+                ix = fai(x);
+                /*
+                 * Set expadjust to compensate for that.
+                 */
+                expadjust = -27;
+
+                /* Now we need to handle negative x as above. */
+                if (ix & 0x80000000)
+                    goto y_ok_x_negative;
+                else
+                    goto mainpath;
+            } else if ((ix - 0x00800000) < (0x7f800000 - 0x00800000)) {
+                /* normal positive x, back here from denormal-y case below */
+                goto mainpath;
+            }
+        } else if (((iy << 1) + 0x02000000) >= 0x02000000) { /* denormal, nearly-denormal or zero y */
+            if (y == 0.0F) {
+                 /*
+                 * y == 0. Any finite x returns 1 here. (Quiet NaNs
+                 * do too, but we handle that below since we don't
+                 * mind doing them more slowly.)
+                 */
+                if ((ix << 1) != 0 && (ix << 1) < 0xFF000000)
+                    return 1.0f;
+            } else {
+                /*
+                 * Denormal or very very small y. In this situation
+                 * we have to be a bit careful, because when we
+                 * break up y into precision-and-a-half later on we
+                 * risk working with denormals and triggering
+                 * underflow exceptions within this function that
+                 * aren't related to the smallness of the output. So
+                 * here we convert all such y values into a standard
+                 * small-but-not-too-small value which will give the
+                 * same output.
+                 *
+                 * What value should that be? Well, we work in
+                 * 16*log2(x) below (equivalently, log to the base
+                 * 2^{1/16}). So the maximum magnitude of that for
+                 * any finite x is about 2416 (= 16 * (128+23), for
+                 * log of the smallest denormal x), i.e. certainly
+                 * less than 2^12. If multiplying that by y gives
+                 * anything of magnitude less than 2^-32 (and even
+                 * that's being generous), the final output will be
+                 * indistinguishable from 1. So any value of y with
+                 * magnitude less than 2^-(32+12) = 2^-44 is
+                 * completely indistinguishable from any other such
+                 * value. Hence we got here in the first place by
+                 * checking the exponent of y against 64 (i.e. -63,
+                 * counting the exponent bias), so we might as well
+                 * normalise all tiny y values to the same threshold
+                 * of 2^-64.
+                 */
+                iy = 0x1f800000 | (iy & 0x80000000);   /* keep the sign; that's important */
+                y = fhex(iy);
+            }
+            goto y_ok_check_x;
+        } else if (((iy << 1) + 0x02000000) < 0x01000000) { /* y in top finite exponent bracket */
+            y = fhex(fai(y) - 0x00800000);   /* scale down by a factor of 2 */
+            goto y_ok_check_x;
+        }
+
+        /*
+         * Having dealt with the above cases, we now know that
+         * either x is zero, infinite or NaN, or y is infinite or
+         * NaN, or both. We can deal with all of those cases without
+         * ever rejoining the main code path.
+         */
+        if ((unsigned)(((ix & 0x7FFFFFFF) - 0x7f800001) < 0x7fc00000 - 0x7f800001) ||
+            (unsigned)(((iy & 0x7FFFFFFF) - 0x7f800001) < 0x7fc00000 - 0x7f800001)) {
+            /*
+             * At least one signalling NaN. Do a token arithmetic
+             * operation on the two operands to provoke an exception
+             * and return the appropriate QNaN.
+             */
+            return FLOAT_INFNAN2(x,y);
+        } else if (ix==0x3f800000 || (iy << 1)==0) {
+            /*
+             * C99 says that 1^anything and anything^0 should both
+             * return 1, _even for a NaN_. I modify that slightly to
+             * apply only to QNaNs (which doesn't violate C99, since
+             * C99 doesn't specify anything about SNaNs at all),
+             * because I can't bring myself not to throw an
+             * exception on an SNaN since its _entire purpose_ is to
+             * throw an exception whenever touched.
+             */
+            return 1.0f;
+        } else
+        if (((ix & 0x7FFFFFFF) > 0x7f800000) ||
+            ((iy & 0x7FFFFFFF) > 0x7f800000)) {
+            /*
+             * At least one QNaN. Do a token arithmetic operation on
+             * the two operands to get the right one to propagate to
+             * the output.
+             */
+            return FLOAT_INFNAN2(x,y);
+        } else if (ix == 0x7f800000) {
+            /*
+             * x = +infinity. Return +infinity for positive y, +0
+             * for negative y, and 1 for zero y.
+             */
+            if (!(iy << 1))
+                return MATHERR_POWF_INF0(x,y);
+            else if (iy & 0x80000000)
+                return 0.0f;
+            else
+                return INFINITY;
+        } else {
+            /*
+             * Repeat the parity analysis of y above, returning 1
+             * (odd), 2 (even) or 0 (fraction).
+             */
+            int ypar, yexp, yunitsbit;
+            yexp = (iy >> 23) & 0xFF;
+            if (yexp < 0x7F)
+                ypar = 0;
+            else if (yexp >= 0x97)
+                ypar = 2;
+            else {
+                yunitsbit = 0x96 - yexp;
+                if (iy & ((1 << yunitsbit)-1))
+                    ypar = 0;
+                else if (iy & (1 << yunitsbit))
+                    ypar = 1;
+                else
+                    ypar = 2;
+            }
+
+            if (ix == 0xff800000) {
+                /*
+                 * x = -infinity. We return infinity or zero
+                 * depending on whether y is positive or negative,
+                 * and the sign is negative iff y is an odd integer.
+                 * (SGT: I don't like this, but it's what C99
+                 * mandates.)
+                 */
+                if (!(iy & 0x80000000)) {
+                    if (ypar == 1)
+                        return -INFINITY;
+                    else
+                        return INFINITY;
+                } else {
+                    if (ypar == 1)
+                        return -0.0f;
+                    else
+                        return +0.0f;
+                }
+            } else if (ix == 0) {
+                /*
+                 * x = +0. We return +0 for all positive y including
+                 * infinity; a divide-by-zero-like error for all
+                 * negative y including infinity; and an 0^0 error
+                 * for zero y.
+                 */
+                if ((iy << 1) == 0)
+                    return MATHERR_POWF_00(x,y);
+                else if (iy & 0x80000000)
+                    return MATHERR_POWF_0NEGEVEN(x,y);
+                else
+                    return +0.0f;
+            } else if (ix == 0x80000000) {
+                /*
+                 * x = -0. We return errors in almost all cases (the
+                 * exception being positive integer y, in which case
+                 * we return a zero of the appropriate sign), but
+                 * the errors are almost all different. Gah.
+                 */
+                if ((iy << 1) == 0)
+                    return MATHERR_POWF_00(x,y);
+                else if (iy == 0x7f800000)
+                    return MATHERR_POWF_NEG0FRAC(x,y);
+                else if (iy == 0xff800000)
+                    return MATHERR_POWF_0NEG(x,y);
+                else if (iy & 0x80000000)
+                    return (ypar == 0 ? MATHERR_POWF_0NEG(x,y) :
+                            ypar == 1 ? MATHERR_POWF_0NEGODD(x,y) :
+                            /* ypar == 2 ? */ MATHERR_POWF_0NEGEVEN(x,y));
+                else
+                    return (ypar == 0 ? MATHERR_POWF_NEG0FRAC(x,y) :
+                            ypar == 1 ? -0.0f :
+                            /* ypar == 2 ? */ +0.0f);
+            } else {
+                /*
+                 * Now we know y is an infinity of one sign or the
+                 * other and x is finite and nonzero. If x == -1 (+1
+                 * is already ruled out), we return +1; otherwise
+                 * C99 mandates that we return either +0 or +inf,
+                 * the former iff exactly one of |x| < 1 and y<0 is
+                 * true.
+                 */
+                if (ix == 0xbf800000) {
+                    return +1.0f;
+                } else if (!((ix << 1) < 0x7f000000) ^ !(iy & 0x80000000)) {
+                    return +0.0f;
+                }
+                else {
+                    return INFINITY;
+                }
+            }
+        }
+    }
+
+    mainpath:
+
+#define PHMULTIPLY(rh,rl, xh,xl, yh,yl) do { \
+    float tmph, tmpl; \
+    tmph = (xh) * (yh); \
+    tmpl = (xh) * (yl) + (xl) * ((yh)+(yl)); \
+/* printf("PHMULTIPLY: tmp=%08x+%08x\n", fai(tmph), fai(tmpl)); */ \
+    (rh) = CLEARBOTTOMHALF(tmph + tmpl); \
+    (rl) = tmpl + (tmph - (rh)); \
+} while (0)
+
+/*
+ * Same as the PHMULTIPLY macro above, but bounds the absolute value
+ * of rh+rl. In multiplications uncontrolled enough that rh can go
+ * infinite, we can get an IVO exception from the subtraction tmph -
+ * rh, so we should spot that case in advance and avoid it.
+ */
+#define PHMULTIPLY_SATURATE(rh,rl, xh,xl, yh,yl, bound) do {            \
+        float tmph, tmpl;                                               \
+        tmph = (xh) * (yh);                                             \
+        if (fabsf(tmph) > (bound)) {                                  \
+            (rh) = copysignf((bound),(tmph));                           \
+            (rl) = 0.0f;                                                \
+        } else {                                                        \
+            tmpl = (xh) * (yl) + (xl) * ((yh)+(yl));                    \
+            (rh) = CLEARBOTTOMHALF(tmph + tmpl);                        \
+            (rl) = tmpl + (tmph - (rh));                                \
+        }                                                               \
+    } while (0)
+
+    /*
+     * Determine log2 of x to relative prec-and-a-half, as logh +
+     * logl.
+     *
+     * Well, we're actually computing 16*log2(x), so that it's the
+     * right size for the subsequently fiddly messing with powers of
+     * 2^(1/16) in the exp step at the end.
      */
-	yisint  = 0;
-	if(hx<0) {
-	    if(iy>=0x4b800000) yisint = 2; /* even integer y */
-	    else if(iy>=0x3f800000) {
-		k = (iy>>23)-0x7f;	   /* exponent */
-		j = iy>>(23-k);
-		if((j<<(23-k))==iy) yisint = 2-(j&1);
-	    }
-	}
-
-    /* special value of y */
-	if (iy==0x7f800000) {	/* y is +-inf */
-	    if (ix==0x3f800000)
-	        return  one;	/* (-1)**+-inf is NaN */
-	    else if (ix > 0x3f800000)/* (|x|>1)**+-inf = inf,0 */
-	        return (hy>=0)? y: zero;
-	    else			/* (|x|<1)**-,+inf = inf,0 */
-	        return (hy<0)?-y: zero;
-	}
-	if(iy==0x3f800000) {	/* y is  +-1 */
-	    if(hy<0) return one/x; else return x;
-	}
-	if(hy==0x40000000) return x*x; /* y is  2 */
-	if(hy==0x3f000000) {	/* y is  0.5 */
-	    if(hx>=0)	/* x >= +0 */
-	    return __ieee754_sqrtf(x);
-	}
-
-	ax   = fabsf(x);
-    /* special value of x */
-	if(ix==0x7f800000||ix==0||ix==0x3f800000){
-	    z = ax;			/*x is +-0,+-inf,+-1*/
-	    if(hy<0) z = one/z;	/* z = (1/|x|) */
-	    if(hx<0) {
-		if(((ix-0x3f800000)|yisint)==0) {
-		    z = (z-z)/(z-z); /* (-1)**non-int is NaN */
-		} else if(yisint==1)
-		    z = -z;		/* (x<0)**odd = -(|x|**odd) */
-	    }
-	    return z;
-	}
-
-	n = ((u_int32_t)hx>>31)-1;
-
-    /* (x<0)**(non-int) is NaN */
-	if((n|yisint)==0) return (x-x)/(x-x);
-
-	sn = one; /* s (sign of result -ve**odd) = -1 else = 1 */
-	if((n|(yisint-1))==0) sn = -one;/* (-ve)**(odd int) */
-
-    /* |y| is huge */
-	if(iy>0x4d000000) { /* if |y| > 2**27 */
-	/* over/underflow if x is not close to one */
-	    if(ix<0x3f7ffff8) return (hy<0)? sn*huge*huge:sn*tiny*tiny;
-	    if(ix>0x3f800007) return (hy>0)? sn*huge*huge:sn*tiny*tiny;
-	/* now |1-x| is tiny <= 2**-20, suffice to compute
-	   log(x) by x-x^2/2+x^3/3-x^4/4 */
-	    t = ax-1;		/* t has 20 trailing zeros */
-	    w = (t*t)*((float)0.5-t*((float)0.333333333333-t*(float)0.25));
-	    u = ivln2_h*t;	/* ivln2_h has 16 sig. bits */
-	    v = t*ivln2_l-w*ivln2;
-	    t1 = u+v;
-	    GET_FLOAT_WORD(is,t1);
-	    SET_FLOAT_WORD(t1,is&0xfffff000);
-	    t2 = v-(t1-u);
-	} else {
-	    float s2,s_h,s_l,t_h,t_l;
-	    n = 0;
-	/* take care subnormal number */
-	    if(ix<0x00800000)
-		{ax *= two24; n -= 24; GET_FLOAT_WORD(ix,ax); }
-	    n  += ((ix)>>23)-0x7f;
-	    j  = ix&0x007fffff;
-	/* determine interval */
-	    ix = j|0x3f800000;		/* normalize ix */
-	    if(j<=0x1cc471) k=0;	/* |x|<sqrt(3/2) */
-	    else if(j<0x5db3d7) k=1;	/* |x|<sqrt(3)   */
-	    else {k=0;n+=1;ix -= 0x00800000;}
-	    SET_FLOAT_WORD(ax,ix);
-
-	/* compute s = s_h+s_l = (x-1)/(x+1) or (x-1.5)/(x+1.5) */
-	    u = ax-bp[k];		/* bp[0]=1.0, bp[1]=1.5 */
-	    v = one/(ax+bp[k]);
-	    s = u*v;
-	    s_h = s;
-	    GET_FLOAT_WORD(is,s_h);
-	    SET_FLOAT_WORD(s_h,is&0xfffff000);
-	/* t_h=ax+bp[k] High */
-	    is = ((ix>>1)&0xfffff000)|0x20000000;
-	    SET_FLOAT_WORD(t_h,is+0x00400000+(k<<21));
-	    t_l = ax - (t_h-bp[k]);
-	    s_l = v*((u-s_h*t_h)-s_h*t_l);
-	/* compute log(ax) */
-	    s2 = s*s;
-	    r = s2*s2*(L1+s2*(L2+s2*(L3+s2*(L4+s2*(L5+s2*L6)))));
-	    r += s_l*(s_h+s);
-	    s2  = s_h*s_h;
-	    t_h = (float)3.0+s2+r;
-	    GET_FLOAT_WORD(is,t_h);
-	    SET_FLOAT_WORD(t_h,is&0xfffff000);
-	    t_l = r-((t_h-(float)3.0)-s2);
-	/* u+v = s*(1+...) */
-	    u = s_h*t_h;
-	    v = s_l*t_h+t_l*s;
-	/* 2/(3log2)*(s+...) */
-	    p_h = u+v;
-	    GET_FLOAT_WORD(is,p_h);
-	    SET_FLOAT_WORD(p_h,is&0xfffff000);
-	    p_l = v-(p_h-u);
-	    z_h = cp_h*p_h;		/* cp_h+cp_l = 2/(3*log2) */
-	    z_l = cp_l*p_h+p_l*cp+dp_l[k];
-	/* log2(ax) = (s+..)*2/(3*log2) = n + dp_h + z_h + z_l */
-	    t = (float)n;
-	    t1 = (((z_h+z_l)+dp_h[k])+t);
-	    GET_FLOAT_WORD(is,t1);
-	    SET_FLOAT_WORD(t1,is&0xfffff000);
-	    t2 = z_l-(((t1-t)-dp_h[k])-z_h);
-	}
-
-    /* split up y into y1+y2 and compute (y1+y2)*(t1+t2) */
-	GET_FLOAT_WORD(is,y);
-	SET_FLOAT_WORD(y1,is&0xfffff000);
-	p_l = (y-y1)*t1+y*t2;
-	p_h = y1*t1;
-	z = p_l+p_h;
-	GET_FLOAT_WORD(j,z);
-	if (j>0x43000000)				/* if z > 128 */
-	    return sn*huge*huge;			/* overflow */
-	else if (j==0x43000000) {			/* if z == 128 */
-	    if(p_l+ovt>z-p_h) return sn*huge*huge;	/* overflow */
-	}
-	else if ((j&0x7fffffff)>0x43160000)		/* z <= -150 */
-	    return sn*tiny*tiny;			/* underflow */
-	else if (j==0xc3160000){			/* z == -150 */
-	    if(p_l<=z-p_h) return sn*tiny*tiny;		/* underflow */
-	}
+    if (__builtin_expect((ix - 0x3f7ff000) <= (0x3f801000 - 0x3f7ff000), 0)) {
+        /*
+         * For x this close to 1, we write x = 1 + t and then
+         * compute t - t^2/2 + t^3/3 - t^4/4; and the neat bit is
+         * that t itself, being the bottom half of an input
+         * mantissa, is in half-precision already, so the output is
+         * naturally in canonical prec-and-a-half form.
+         */
+        float t = x - 1.0;
+        float lnh, lnl;
+        /*
+         * Compute natural log of x in prec-and-a-half.
+         */
+        lnh = t;
+        lnl = - (t * t) * ((1.0f/2.0f) - t * ((1.0f/3.0f) - t * (1.0f/4.0f)));
+
+        /*
+         * Now we must scale by 16/log(2), still in prec-and-a-half,
+         * to turn this from natural log(x) into 16*log2(x).
+         */
+        PHMULTIPLY(logh, logl, lnh, lnl, 0x1.716p+4F, -0x1.7135a8p-9F);
+    } else {
+        /*
+         * For all other x, we start by normalising to [1,2), and
+         * then dividing that further into subintervals. For each
+         * subinterval we pick a number a in that interval, compute
+         * s = (x-a)/(x+a) in precision-and-a-half, and then find
+         * the log base 2 of (1+s)/(1-s), still in precision-and-a-
+         * half.
+         *
+         * Why would we do anything so silly? For two main reasons.
+         *
+         * Firstly, if s = (x-a)/(x+a), then a bit of algebra tells
+         * us that x = a * (1+s)/(1-s); so once we've got
+         * log2((1+s)/(1-s)), we need only add on log2(a) and then
+         * we've got log2(x). So this lets us treat all our
+         * subintervals in essentially the same way, rather than
+         * requiring a separate approximation for each one; the only
+         * correction factor we need is to store a table of the
+         * base-2 logs of all our values of a.
+         *
+         * Secondly, log2((1+s)/(1-s)) is a nice thing to compute,
+         * once we've got s. Switching to natural logarithms for the
+         * moment (it's only a scaling factor to sort that out at
+         * the end), we write it as the difference of two logs:
+         *
+         *   log((1+s)/(1-s)) = log(1+s) - log(1-s)
+         *
+         * Now recall that Taylor series expansion gives us
+         *
+         *   log(1+s) = s - s^2/2 + s^3/3 - ...
+         *
+         * and therefore we also have
+         *
+         *   log(1-s) = -s - s^2/2 - s^3/3 - ...
+         *
+         * These series are exactly the same except that the odd
+         * terms (s, s^3 etc) have flipped signs; so subtracting the
+         * latter from the former gives us
+         *
+         *   log(1+s) - log(1-s) = 2s + 2s^3/3 + 2s^5/5 + ...
+         *
+         * which requires only half as many terms to be computed
+         * before the powers of s get too small to see. Then, of
+         * course, we have to scale the result by 1/log(2) to
+         * convert natural logs into logs base 2.
+         *
+         * To compute the above series in precision-and-a-half, we
+         * first extract a factor of 2s (which we can multiply back
+         * in later) so that we're computing 1 + s^2/3 + s^4/5 + ...
+         * and then observe that if s starts off small enough to
+         * make s^2/3 at most 2^-12, we need only compute the first
+         * couple of terms in laborious prec-and-a-half, and can
+         * delegate everything after that to a simple polynomial
+         * approximation whose error will end up at the bottom of
+         * the low word of the result.
+         *
+         * How many subintervals does that mean we need?
+         *
+         * To go back to s = (x-a)/(x+a). Let x = a + e, for some
+         * positive e. Then |s| = |e| / |2a+e| <= |e/2a|. So suppose
+         * we have n subintervals of equal width covering the space
+         * from 1 to 2. If a is at the centre of each interval, then
+         * we have e at most 1/2n and a can equal any of 1, 1+1/n,
+         * 1+2/n, ... 1+(n-1)/n. In that case, clearly the largest
+         * value of |e/2a| is given by the largest e (i.e. 1/2n) and
+         * the smallest a (i.e. 1); so |s| <= 1/4n. Hence, when we
+         * know how big we're prepared to let s be, we simply make
+         * sure 1/4n is at most that.
+         *
+         * And if we want s^2/3 to be at most 2^-12, then that means
+         * s^2 is at most 3*2^-12, so that s is at most sqrt(3)*2^-6
+         * = 0.02706. To get 1/4n smaller than that, we need to have
+         * n>=9.23; so we'll set n=16 (for ease of bit-twiddling),
+         * and then s is at most 1/64.
+         */
+        int n, i;
+        float a, ax, sh, sl, lsh, lsl;
+
+        /*
+         * Let ax be x normalised to a single exponent range.
+         * However, the exponent range in question is not a simple
+         * one like [1,2). What we do is to round up the top four
+         * bits of the mantissa, so that the top 1/32 of each
+         * natural exponent range rounds up to the next one and is
+         * treated as a displacement from the lowest a in that
+         * range.
+         *
+         * So this piece of bit-twiddling gets us our input exponent
+         * and our subinterval index.
+         */
+        n = (ix + 0x00040000) >> 19;
+        i = n & 15;
+        n = ((n >> 4) & 0xFF) - 0x7F;
+        ax = fhex(ix - (n << 23));
+        n += expadjust;
+
+        /*
+         * Compute the subinterval centre a.
+         */
+        a = 1.0f + i * (1.0f/16.0f);
+
+        /*
+         * Compute s = (ax-a)/(ax+a), in precision-and-a-half.
+         */
+        {
+            float u, vh, vl, vapprox, rvapprox;
+
+            u = ax - a;                /* exact numerator */
+            vapprox = ax + a;          /* approximate denominator */
+            vh = CLEARBOTTOMHALF(vapprox);
+            vl = (a - vh) + ax;        /* vh+vl is exact denominator */
+            rvapprox = 1.0f/vapprox;   /* approximate reciprocal of denominator */
+
+            sh = CLEARBOTTOMHALF(u * rvapprox);
+            sl = ((u - sh*vh) - sh*vl) * rvapprox;
+        }
+
+        /*
+         * Now compute log2(1+s) - log2(1-s). We do this in several
+         * steps.
+         *
+         * By polynomial approximation, we compute
+         *
+         *        log(1+s) - log(1-s)
+         *    p = ------------------- - 1
+         *                2s
+         *
+         * in single precision only, using a single-precision
+         * approximation to s. This polynomial has s^2 as its
+         * lowest-order term, so we expect the result to be in
+         * [0,2^-12).
+         *
+         * Then we form a prec-and-a-half number out of 1 and p,
+         * which is therefore equal to (log(1+s) - log(1-s))/(2s).
+         *
+         * Finally, we do two prec-and-a-half multiplications: one
+         * by s itself, and one by the constant 32/log(2).
+         */
+        {
+            float s = sh + sl;
+            float s2 = s*s;
+            /*
+             * p is actually a polynomial in s^2, with the first
+             * term constrained to zero. In other words, treated on
+             * its own terms, we're computing p(s^2) such that p(x)
+             * is an approximation to the sum of the series 1/3 +
+             * x/5 + x^2/7 + ..., valid on the range [0, 1/40^2].
+             */
+            float p = s2 * (0.33333332920177422f + s2 * 0.20008275183621479f);
+            float th, tl;
+
+            PHMULTIPLY(th,tl, 1.0f,p, sh,sl);
+            PHMULTIPLY(lsh,lsl, th,tl, 0x1.716p+5F,-0x1.7135a8p-8F);
+        }
+
+        /*
+         * And our final answer for 16*log2(x) is equal to 16n (from
+         * the exponent), plus lsh+lsl (the result of the above
+         * computation), plus 16*log2(a) which we must look up in a
+         * table.
+         */
+        {
+            struct f2 { float h, l; };
+            static const struct f2 table[16] = {
+                /*
+                 * When constructing this table, we have to be sure
+                 * that we produce the same values of a which will
+                 * be produced by the computation above. Ideally, I
+                 * would tell Perl to actually do its _arithmetic_
+                 * in single precision here; but I don't know a way
+                 * to do that, so instead I just scrupulously
+                 * convert every intermediate value to and from SP.
+                 */
+                // perl -e 'for ($i=0; $i<16; $i++) { $v = unpack "f", pack "f", 1/16.0; $a = unpack "f", pack "f", $i * $v; $a = unpack "f", pack "f", $a+1.0; $l = 16*log($a)/log(2); $top = unpack "f", pack "f", int($l*256.0+0.5)/256.0; $bot = unpack "f", pack "f", $l - $top; printf "{0f_%08X,0f_%08X}, ", unpack "VV", pack "ff", $top, $bot; } print "\n"' | fold -s -w56 | sed 's/^/                /'
+                {0x0p+0F,0x0p+0F}, {0x1.66p+0F,0x1.fb7d64p-11F},
+                {0x1.5cp+1F,0x1.a39fbep-15F}, {0x1.fcp+1F,-0x1.f4a37ep-10F},
+                {0x1.49cp+2F,-0x1.87b432p-10F}, {0x1.91cp+2F,-0x1.15db84p-12F},
+                {0x1.d68p+2F,-0x1.583f9ap-11F}, {0x1.0c2p+3F,-0x1.f5fe54p-10F},
+                {0x1.2b8p+3F,0x1.a39fbep-16F}, {0x1.49ap+3F,0x1.e12f34p-11F},
+                {0x1.66ap+3F,0x1.1c8f12p-18F}, {0x1.828p+3F,0x1.3ab7cep-14F},
+                {0x1.9d6p+3F,-0x1.30158p-12F}, {0x1.b74p+3F,0x1.291eaap-10F},
+                {0x1.d06p+3F,-0x1.8125b4p-10F}, {0x1.e88p+3F,0x1.8d66c4p-10F},
+            };
+            float lah = table[i].h, lal = table[i].l;
+            float fn = 16*n;
+            logh = CLEARBOTTOMHALF(lsl + lal + lsh + lah + fn);
+            logl = lsl - ((((logh - fn) - lah) - lsh) - lal);
+        }
+    }
+
     /*
-     * compute 2**(p_h+p_l)
+     * Now we have 16*log2(x), multiply it by y in prec-and-a-half.
      */
-	i = j&0x7fffffff;
-	k = (i>>23)-0x7f;
-	n = 0;
-	if(i>0x3f000000) {		/* if |z| > 0.5, set n = [z+0.5] */
-	    n = j+(0x00800000>>(k+1));
-	    k = ((n&0x7fffffff)>>23)-0x7f;	/* new k for n */
-	    SET_FLOAT_WORD(t,n&~(0x007fffff>>k));
-	    n = ((n&0x007fffff)|0x00800000)>>(23-k);
-	    if(j<0) n = -n;
-	    p_h -= t;
-	}
-	t = p_l+p_h;
-	GET_FLOAT_WORD(is,t);
-	SET_FLOAT_WORD(t,is&0xffff8000);
-	u = t*lg2_h;
-	v = (p_l-(t-p_h))*lg2+t*lg2_l;
-	z = u+v;
-	w = v-(z-u);
-	t  = z*z;
-	t1  = z - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));
-	r  = (z*t1)/(t1-two)-(w+z*w);
-	z  = one-(r-z);
-	GET_FLOAT_WORD(j,z);
-	j += (n<<23);
-	if((j>>23)<=0) z = scalbnf(z,n);	/* subnormal output */
-	else SET_FLOAT_WORD(z,j);
-	return sn*z;
+    {
+        float yh, yl;
+        int savedexcepts;
+
+        yh = CLEARBOTTOMHALF(y);
+        yl = y - yh;
+
+        /* This multiplication could become infinite, so to avoid IVO
+         * in PHMULTIPLY we bound the output at 4096, which is big
+         * enough to allow any non-overflowing case through
+         * unmodified. Also, we must mask out the OVF exception, which
+         * we won't want left in the FP status word in the case where
+         * rlogh becomes huge and _negative_ (since that will be an
+         * underflow from the perspective of powf's return value, not
+         * an overflow). */
+        savedexcepts = __ieee_status(0,0) & (FE_IEEE_OVERFLOW | FE_IEEE_UNDERFLOW);
+        PHMULTIPLY_SATURATE(rlogh, rlogl, logh, logl, yh, yl, 4096.0f);
+        __ieee_status(FE_IEEE_OVERFLOW | FE_IEEE_UNDERFLOW, savedexcepts);
+    }
+
+    /*
+     * And raise 2 to the power of whatever that gave. Again, this
+     * is done in three parts: the fractional part of our input is
+     * fed through a polynomial approximation, all but the bottom
+     * four bits of the integer part go straight into the exponent,
+     * and the bottom four bits of the integer part index into a
+     * lookup table of powers of 2^(1/16) in prec-and-a-half.
+     */
+    {
+        float rlog = rlogh + rlogl;
+        int i16 = (rlog + (rlog < 0 ? -0.5f : +0.5f));
+        float rlogi = i16 >> 4;
+
+        float x = rlogl + (rlogh - i16);
+
+        static const float powersof2to1over16top[16] = { 0x1p+0F, 0x1.0b4p+0F, 0x1.172p+0F, 0x1.238p+0F, 0x1.306p+0F, 0x1.3dep+0F, 0x1.4bep+0F, 0x1.5aap+0F, 0x1.6ap+0F, 0x1.7ap+0F, 0x1.8acp+0F, 0x1.9c4p+0F, 0x1.ae8p+0F, 0x1.c18p+0F, 0x1.d58p+0F, 0x1.ea4p+0F };
+        static const float powersof2to1over16bot[16] = { 0x0p+0F, 0x1.586cfap-12F, 0x1.7078fap-13F, 0x1.e9b9d6p-14F, 0x1.fc1464p-13F, 0x1.4c9824p-13F, 0x1.dad536p-12F, 0x1.07dd48p-12F, 0x1.3cccfep-13F, 0x1.1473ecp-12F, 0x1.ca8456p-13F, 0x1.230548p-13F, 0x1.3f32b6p-13F, 0x1.9bdd86p-12F, 0x1.8dcfbap-16F, 0x1.5f454ap-13F };
+        static const float powersof2to1over16all[16] = { 0x1p+0F, 0x1.0b5586p+0F, 0x1.172b84p+0F, 0x1.2387a6p+0F, 0x1.306fep+0F, 0x1.3dea64p+0F, 0x1.4bfdaep+0F, 0x1.5ab07ep+0F, 0x1.6a09e6p+0F, 0x1.7a1148p+0F, 0x1.8ace54p+0F, 0x1.9c4918p+0F, 0x1.ae89fap+0F, 0x1.c199bep+0F, 0x1.d5818ep+0F, 0x1.ea4afap+0F };
+        /*
+         * Coefficients generated using the command
+
+./auxiliary/remez.jl --suffix=f -- '-1/BigFloat(2)' '+1/BigFloat(2)' 2 0 'expm1(x*log(BigFloat(2))/16)/x'
+
+         */
+        float p = x * (
+            4.332169876512769231967668743345473181486157887703125512683507537369503902991722e-02f+x*(9.384123108485637159805511308039285411735300871134684682779057580789341719567367e-04f+x*(1.355120515540562256928614563584948866224035897564701496826514330445829352922309e-05f))
+            );
+        int index = (i16 & 15);
+        p = powersof2to1over16top[index] + (powersof2to1over16bot[index] + powersof2to1over16all[index]*p);
+
+        if (
+            fabsf(rlogi) < 126.0f
+            ) {
+            return sign * p * fhex((unsigned)((127.0f+rlogi) * 8388608.0f));
+        } else if (
+                   fabsf(rlogi) < 192.0f
+                   ) {
+            int i = rlogi;
+            float ret;
+
+            ret = sign * p *
+                fhex((unsigned)((0x7f+i/2) * 8388608)) *
+                fhex((unsigned)((0x7f+i-i/2) * 8388608));
+
+            if ((fai(ret) << 1) == 0xFF000000)
+                return MATHERR_POWF_OFL(x, y, sign);
+            else if ((fai(ret) << 1) == 0)
+                return MATHERR_POWF_UFL(x, y, sign);
+            else
+                return FLOAT_CHECKDENORM(ret);
+        } else {
+            if (rlogi < 0)
+                return MATHERR_POWF_UFL(x, y, sign);
+            else
+                return MATHERR_POWF_OFL(x, y, sign);
+        }
+    }
 }
diff --git a/libm/upstream-freebsd/lib/msun/src/funder.c b/libm/upstream-freebsd/lib/msun/src/funder.c
new file mode 100644
index 000000000..ab952e1e7
--- /dev/null
+++ b/libm/upstream-freebsd/lib/msun/src/funder.c
@@ -0,0 +1,65 @@
+/*
+ *  funder.c - manually provoke SP exceptions for
+ *
+ *  Copyright (C) 2009-2015, ARM Limited, All Rights Reserved
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  This file is part of the Optimized Routines project
+ */
+
+#include "math_private.h"
+#include <fenv.h>
+
+__inline float _flt_infnan2(float x, float y)
+{
+  return x+y;
+}
+
+__inline float _flt_infnan(float x)
+{
+  return x+x;
+}
+
+float _flt_underflow(void)
+{
+#ifdef CLANG_EXCEPTIONS
+  feraiseexcept(FE_UNDERFLOW);
+#endif
+  return 0x1p-95F * 0x1p-95F;
+}
+
+float _flt_overflow(void)
+{
+#ifdef CLANG_EXCEPTIONS
+  feraiseexcept(FE_OVERFLOW);
+#endif
+  return 0x1p+97F * 0x1p+97F;
+}
+
+float _flt_invalid(void)
+{
+#ifdef CLANG_EXCEPTIONS
+  feraiseexcept(FE_INVALID);
+#endif
+  return 0.0f / 0.0f;
+}
+
+float _flt_divzero(void)
+{
+#ifdef CLANG_EXCEPTIONS
+  feraiseexcept(FE_DIVBYZERO);
+#endif
+  return 1.0f / 0.0f;
+}
diff --git a/libm/upstream-freebsd/lib/msun/src/ieee_status.c b/libm/upstream-freebsd/lib/msun/src/ieee_status.c
new file mode 100644
index 000000000..5d96a4efb
--- /dev/null
+++ b/libm/upstream-freebsd/lib/msun/src/ieee_status.c
@@ -0,0 +1,52 @@
+/*
+ *  ieee_status.c
+ *
+ *  Copyright (C) 2015, ARM Limited, All Rights Reserved
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  This file is part of the Optimized Routines project
+ */
+
+#include "math_private.h"
+
+__inline unsigned __ieee_status(unsigned bicmask, unsigned xormask)
+{
+#ifdef __FP_FENV_EXCEPTIONS
+  unsigned status_word;
+  unsigned ret;
+
+#ifdef __FP_FENV_ROUNDING
+# define MASK (1<<27)|FE_IEEE_FLUSHZERO|FE_IEEE_MASK_ALL_EXCEPT|FE_IEEE_ALL_EXCEPT|FE_IEEE_ROUND_MASK
+#else
+# define MASK (1<<27)|FE_IEEE_FLUSHZERO|FE_IEEE_MASK_ALL_EXCEPT|FE_IEEE_ALL_EXCEPT
+#endif
+
+  /* mask out read-only bits */
+  bicmask &= MASK;
+  xormask &= MASK;
+
+  /* modify the status word */
+//  __asm__ __volatile__ ("mrs %0, fpsr" : "=r" (status_word));
+  ret = status_word;
+  status_word &= ~bicmask;
+  status_word ^= xormask;
+//  __asm__ __volatile__ ("msr fpsr, %0" : : "r" (status_word));
+
+  /* and return what it used to be */
+  return ret;
+#else
+  return 0;
+#endif
+}
diff --git a/libm/upstream-freebsd/lib/msun/src/math_private.h b/libm/upstream-freebsd/lib/msun/src/math_private.h
index 1f10e8b9a..757ef0571 100644
--- a/libm/upstream-freebsd/lib/msun/src/math_private.h
+++ b/libm/upstream-freebsd/lib/msun/src/math_private.h
@@ -19,6 +19,7 @@
 
 #include <sys/types.h>
 #include <machine/endian.h>
+#include <errno.h>
 
 /*
  * The original fdlibm code used statements like:
@@ -773,4 +774,104 @@ long double __kernel_sinl(long double, long double, int);
 long double __kernel_cosl(long double, long double);
 long double __kernel_tanl(long double, long double, int);
 
+#define __FP_IEEE
+#define __FP_FENV_EXCEPTIONS
+#define __FP_FENV_ROUNDING
+#define __FP_INEXACT_EXCEPTION
+
+#define __set_errno(val) (errno = (val))
+
+#define __FLT(x) (*(unsigned *)&(x))
+#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
+#  define __LO(x) (*(1 + (unsigned *)&(x)))
+#  define __HI(x) (*(unsigned *)&(x))
+#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
+#  define __HI(x) (*(1 + (unsigned *)&(x)))
+#  define __LO(x) (*(unsigned *)&(x))
+#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
+
+// FIXME: Implement these without type punning.
+static __inline unsigned int fai(float f) { return __FLT(f); }
+static __inline float fhex(unsigned int n) { float f; __FLT(f) = n; return f; }
+
+#define CLEARBOTTOMHALF(x) fhex((fai(x) + 0x00000800) & 0xFFFFF000)
+
+#define FE_IEEE_OVERFLOW           (0x00000004)
+#define FE_IEEE_UNDERFLOW          (0x00000008)
+#define FE_IEEE_FLUSHZERO          (0x01000000)
+#define FE_IEEE_ROUND_TONEAREST    (0x00000000)
+#define FE_IEEE_ROUND_UPWARD       (0x00400000)
+#define FE_IEEE_ROUND_DOWNWARD     (0x00800000)
+#define FE_IEEE_ROUND_TOWARDZERO   (0x00C00000)
+#define FE_IEEE_ROUND_MASK         (0x00C00000)
+#define FE_IEEE_MASK_INVALID       (0x00000100)
+#define FE_IEEE_MASK_DIVBYZERO     (0x00000200)
+#define FE_IEEE_MASK_OVERFLOW      (0x00000400)
+#define FE_IEEE_MASK_UNDERFLOW     (0x00000800)
+#define FE_IEEE_MASK_INEXACT       (0x00001000)
+#define FE_IEEE_MASK_INPUTDENORMAL (0x00008000)
+#define FE_IEEE_MASK_ALL_EXCEPT    (0x00009F00)
+#define FE_IEEE_INVALID            (0x00000001)
+#define FE_IEEE_DIVBYZERO          (0x00000002)
+#define FE_IEEE_INEXACT            (0x00000010)
+#define FE_IEEE_INPUTDENORMAL      (0x00000080)
+#define FE_IEEE_ALL_EXCEPT         (0x0000009F)
+
+extern double _dbl_overflow(void);
+extern float _flt_overflow(void);
+extern double _dbl_underflow(void);
+extern float _flt_underflow(void);
+extern double _dbl_invalid(void);
+extern float _flt_invalid(void);
+extern double _dbl_divzero(void);
+extern float _flt_divzero(void);
+#define DOUBLE_OVERFLOW ( _dbl_overflow() )
+#define FLOAT_OVERFLOW ( _flt_overflow() )
+#define DOUBLE_UNDERFLOW ( _dbl_underflow() )
+#define FLOAT_UNDERFLOW ( _flt_underflow() )
+#define DOUBLE_INVALID ( _dbl_invalid() )
+#define FLOAT_INVALID  ( _flt_invalid() )
+#define DOUBLE_DIVZERO ( _dbl_divzero() )
+#define FLOAT_DIVZERO  ( _flt_divzero() )
+
+extern float  _flt_infnan(float);
+extern float  _flt_infnan2(float, float);
+extern double _dbl_infnan(double);
+extern double _dbl_infnan2(double, double);
+extern unsigned __ieee_status(unsigned, unsigned);
+extern double kernel_tan(double, double, int);
+
+#define FLOAT_INFNAN(x) _flt_infnan(x)
+#define FLOAT_INFNAN2(x,y) _flt_infnan2(x,y)
+#define DOUBLE_INFNAN(x) _dbl_infnan(x)
+#define DOUBLE_INFNAN2(x,y) _dbl_infnan2(x,y)
+
+#define MATHERR_POWF_00(x,y) (__set_errno(EDOM), 1.0f)
+#define MATHERR_POWF_INF0(x,y) (__set_errno(EDOM), 1.0f)
+#define MATHERR_POWF_0NEG(x,y) (__set_errno(ERANGE), FLOAT_DIVZERO)
+#define MATHERR_POWF_NEG0FRAC(x,y) (0.0f)
+#define MATHERR_POWF_0NEGODD(x,y) (__set_errno(ERANGE), -FLOAT_DIVZERO)
+#define MATHERR_POWF_0NEGEVEN(x,y) (__set_errno(ERANGE), FLOAT_DIVZERO)
+#define MATHERR_POWF_NEGFRAC(x,y) (__set_errno(EDOM), FLOAT_INVALID)
+#define MATHERR_POWF_ONEINF(x,y) (1.0f)
+#define MATHERR_POWF_OFL(x,y,z) (__set_errno(ERANGE), copysignf(FLOAT_OVERFLOW,z))
+#define MATHERR_POWF_UFL(x,y,z) (__set_errno(ERANGE), copysignf(FLOAT_UNDERFLOW,z))
+#define MATHERR_POWF_UFL(x,y,z) (__set_errno(ERANGE), copysignf(FLOAT_UNDERFLOW,z))
+
+#define MATHERR_LOGF_0(x) (__set_errno(ERANGE), -FLOAT_DIVZERO)
+#define MATHERR_LOGF_NEG(x) (__set_errno(EDOM), FLOAT_INVALID)
+
+#define MATHERR_SIN_INF(x) (__set_errno(EDOM), DOUBLE_INVALID)
+#define MATHERR_SINF_INF(x) (__set_errno(EDOM), FLOAT_INVALID)
+#define MATHERR_COS_INF(x) (__set_errno(EDOM), DOUBLE_INVALID)
+#define MATHERR_COSF_INF(x) (__set_errno(EDOM), FLOAT_INVALID)
+#define MATHERR_TAN_INF(x) (__set_errno(EDOM), DOUBLE_INVALID)
+#define MATHERR_TANF_INF(x) (__set_errno(EDOM), FLOAT_INVALID)
+
+#define MATHERR_EXPF_UFL(x) (__set_errno(ERANGE), FLOAT_UNDERFLOW)
+#define MATHERR_EXPF_OFL(x) (__set_errno(ERANGE), FLOAT_OVERFLOW)
+
+#define FLOAT_CHECKDENORM(x) ( (fpclassify(x) == FP_SUBNORMAL ? FLOAT_UNDERFLOW : 0), x )
+#define DOUBLE_CHECKDENORM(x) ( (fpclassify(x) == FP_SUBNORMAL ? DOUBLE_UNDERFLOW : 0), x )
+
 #endif /* !_MATH_PRIVATE_H_ */
-- 
2.11.0

