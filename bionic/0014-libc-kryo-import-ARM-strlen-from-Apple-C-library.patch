From ca5dcfaec95881c8d221f0e09279559381c6a607 Mon Sep 17 00:00:00 2001
From: Jake Weinstein <xboxlover360@gmail.com>
Date: Sun, 12 Feb 2017 00:01:46 -0500
Subject: [PATCH 14/17] libc: kryo: import ARM strlen from Apple C library

* Significant improvements across the board except on the smallest copies

* Tested on Oneplus 3 (MSM8996)

Before:
BM_string_strlen/8/0              7 ns          7 ns   93955587   1024.13MB/s
BM_string_strlen/64/0            21 ns         20 ns   34163780   2.90906GB/s
BM_string_strlen/512/0          134 ns        133 ns    5274274   3.59157GB/s
BM_string_strlen/1024/0         253 ns        252 ns    2779010   3.78558GB/s
BM_string_strlen/8192/0        1927 ns       1921 ns     364457   3.97223GB/s
BM_string_strlen/16384/0       3841 ns       3828 ns     182848   3.98603GB/s
BM_string_strlen/32768/0       7681 ns       7648 ns      91516   3.99025GB/s
BM_string_strlen/65536/0      15332 ns      15277 ns      45816   3.99528GB/s

After:
BM_string_strlen/8/0              8 ns          7 ns   93917518   1023.45MB/s
BM_string_strlen/64/0            17 ns         16 ns   42739624   3.63841GB/s
BM_string_strlen/512/0          104 ns        103 ns    6799906   4.63327GB/s
BM_string_strlen/1024/0         191 ns        189 ns    3696372   5.03259GB/s
BM_string_strlen/8192/0        1419 ns       1408 ns     497066   5.41889GB/s
BM_string_strlen/16384/0       2811 ns       2789 ns     251533   5.47169GB/s
BM_string_strlen/32768/0       5905 ns       5844 ns     120999   5.22171GB/s
BM_string_strlen/65536/0      11713 ns      11637 ns      58302   5.24495GB/s

* Tested on Pixel XL (MSM8996)

Before:
BM_string_strlen/8/0              7 ns          7 ns   93956028   1023.93MB/s
BM_string_strlen/64/0            21 ns         20 ns   34168816   2.90894GB/s
BM_string_strlen/512/0          133 ns        133 ns    5274287   3.59236GB/s
BM_string_strlen/1024/0         253 ns        252 ns    2775857   3.78402GB/s
BM_string_strlen/8192/0        1934 ns       1922 ns     364237   3.96893GB/s
BM_string_strlen/16384/0       3849 ns       3831 ns     182735   3.98272GB/s
BM_string_strlen/32768/0       7687 ns       7651 ns      91483   3.98868GB/s
BM_string_strlen/65536/0      15372 ns      15288 ns      45779   3.99231GB/s

After:
BM_string_strlen/8/0              8 ns          7 ns   70359966    1021.7MB/s
BM_string_strlen/64/0            17 ns         16 ns   42114105   3.64559GB/s
BM_string_strlen/512/0          109 ns        103 ns    6767682   4.61733GB/s
BM_string_strlen/1024/0         202 ns        190 ns    3684710   5.01499GB/s
BM_string_strlen/8192/0        1489 ns       1409 ns     496871    5.4129GB/s
BM_string_strlen/16384/0       3100 ns       2920 ns     252721   5.22508GB/s
BM_string_strlen/32768/0       6472 ns       6075 ns     115649   5.02376GB/s
BM_string_strlen/65536/0      11890 ns      11453 ns      61173   5.32933GB/s

* Tested on Razer Phone (MSM8998)

Before:
BM_string_strlen/8/0              9 ns          9 ns   81824589   892.252MB/s
BM_string_strlen/64/0            26 ns         25 ns   27524406   2.34424GB/s
BM_string_strlen/512/0          170 ns        169 ns    4132491   2.81509GB/s
BM_string_strlen/1024/0         327 ns        326 ns    2148972   2.92716GB/s
BM_string_strlen/8192/0        2525 ns       2515 ns     278372   3.03382GB/s
BM_string_strlen/16384/0       5038 ns       5017 ns     139524   3.04158GB/s
BM_string_strlen/32768/0      10062 ns      10020 ns      69857   3.04567GB/s
BM_string_strlen/65536/0      20121 ns      20031 ns      34945   3.04697GB/s

After:
BM_string_strlen/8/0              9 ns          9 ns   81862768   892.327MB/s
BM_string_strlen/64/0            20 ns         20 ns   35087838    2.9876GB/s
BM_string_strlen/512/0          118 ns        117 ns    5969643   4.06652GB/s
BM_string_strlen/1024/0         222 ns        221 ns    3160408    4.3057GB/s
BM_string_strlen/8192/0        1688 ns       1681 ns     416485   4.53928GB/s
BM_string_strlen/16384/0       3362 ns       3348 ns     208922   4.55698GB/s
BM_string_strlen/32768/0       6713 ns       6685 ns     104737   4.56501GB/s
BM_string_strlen/65536/0      13493 ns      13436 ns      52100   4.54277GB/s

Change-Id: I735d5cfe6e908f52104647492442a8f3d01acf99
---
 libc/Android.bp                    |  9 ++--
 libc/arch-arm/kryo/bionic/strlen.S | 91 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 97 insertions(+), 3 deletions(-)
 create mode 100644 libc/arch-arm/kryo/bionic/strlen.S

diff --git a/libc/Android.bp b/libc/Android.bp
index 413f3cef8..b608aa859 100644
--- a/libc/Android.bp
+++ b/libc/Android.bp
@@ -943,7 +943,8 @@ cc_library_static {
                     "arch-arm/cortex-a9/bionic/__strcat_chk.S",
                     "arch-arm/cortex-a9/bionic/strcpy.S",
                     "arch-arm/cortex-a9/bionic/__strcpy_chk.S",
-                    "arch-arm/cortex-a9/bionic/strlen.S",
+
+                    "arch-arm/kryo/bionic/strlen.S",
 
                     "arch-arm/cortex-a15/bionic/strcmp.S",
                     "arch-arm/denver/bionic/memmove.S",
@@ -1066,12 +1067,14 @@ cc_library_static {
                     "arch-arm/krait/bionic/__strcat_chk.S",
                     "arch-arm/krait/bionic/__strcpy_chk.S",
 
-                    // Use cortex-a15 versions of strcat/strcpy/strlen.
+                    // Use cortex-a15 versions of strcat/strcpy.
                     "arch-arm/cortex-a15/bionic/stpcpy.S",
                     "arch-arm/cortex-a15/bionic/strcat.S",
                     "arch-arm/cortex-a15/bionic/strcmp.S",
                     "arch-arm/cortex-a15/bionic/strcpy.S",
-                    "arch-arm/cortex-a15/bionic/strlen.S",
+
+		    // Use kryo specific strlen version.
+                    "arch-arm/kryo/bionic/strlen.S",
 
                     "arch-arm/denver/bionic/memmove.S",
                 ],
diff --git a/libc/arch-arm/kryo/bionic/strlen.S b/libc/arch-arm/kryo/bionic/strlen.S
new file mode 100644
index 000000000..121d9aca6
--- /dev/null
+++ b/libc/arch-arm/kryo/bionic/strlen.S
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2011 Apple, Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_LICENSE_HEADER_END@
+ */
+
+#include <private/bionic_asm.h>
+
+.syntax unified
+.code 32
+
+#define addr r0
+#define word r1
+#define temp r2
+#define mask r3
+#define save ip
+#define indx r0
+
+.macro IfWordDoesntContainNUL_SetZ
+//  In each word of the string, we check for NUL bytes via a saturating
+//  unsigned subtraction of each byte from 0x1.  The result of this is
+//  non-zero if and only if the corresponding byte in the string is NUL.
+//  Simply using a TST instruction checks all four bytes for NULs in one
+//  go.
+    uqsub8  temp,   mask,   word
+    tst     temp,           temp
+.endm
+
+.text
+.align 4
+.long 0x0           // padding
+.long 0x01010101    // mask for use in finding NULs
+ENTRY(strlen)
+//  Establish stack frame, load mask that we will use to find NUL bytes,
+//  and set aside a copy of the pointer to the string.
+    push    {r7,lr}
+    mov     r7,     sp
+    ldr     mask,   (strlen-4)
+    add		save,   addr,   #4
+
+//  Load the aligned word that contains the start of the string, then OR
+//  0x01 into any bytes that preceed the start of the string to prevent
+//  false positives when we check for NUL bytes.
+    and     temp,   addr,   #3
+    bic     addr,   addr,   #3
+    lsl     temp,   temp,   #3
+    ldr     word,  [addr],  #4
+    rsb     temp,   temp,   #32
+    orr     word,   word,   mask, lsr temp
+
+//  Check if the string ends in the first word.  If so, don't load any
+//  more of the string; instead jump directly to the cleanup code.
+    IfWordDoesntContainNUL_SetZ
+    bne     1f
+
+.align 4
+//  Load one word of the string on each iteration, and check it for NUL
+//  bytes.  If a NUL is found, fall through into the cleanup code.
+0:  ldr     word,  [addr],  #4
+    IfWordDoesntContainNUL_SetZ
+    beq		0b
+
+//  The last word that we loaded contained a NUL.  Subtracting the saved
+//  pointer from the current pointer gives us the number of bytes from
+//  the start of the string to the word containing the NUL.
+1:  sub     indx,   addr,   save
+//  To that we add the index of the first NUL byte in the word, computed
+//  using REV and CLZ followed by a shift.
+    rev     temp,           temp
+    clz     temp,           temp
+    add     indx,   indx,   temp, lsr #3
+    pop     {r7,pc}
+
+END(strlen)
-- 
2.11.0

